from mjpeg.client import MJPEGClient
import cv2
import numpy as np
import threading
import time
import queue

class MJPEGVideoCapture:
    def __init__(self, url):
        self.url = url
        self.running = False
        self.client = None
        self.frame_queue = queue.Queue(maxsize=1)
        self.thread = None
        
        # Initialize MJPEGClient
        self.client = MJPEGClient(url)
        
        print("VC Opened")
    
    def open(self):
        if not self.running:
            self.running = True
            # Create and enqueue buffers
            bufs = self.client.request_buffers(65536, 50)
            for b in bufs:
                self.client.enqueue_buffer(b)
            
            # Start the client in a background thread
            self.client.start()
            
            # Allow some time for the update thread to start and capture a frame.
            time.sleep(2)
    
    def _update(self):
        while self.running:
            try:
                buf = self.client.dequeue_buffer()
                data = memoryview(buf.data)[:buf.used]
                img_array = np.frombuffer(data, dtype=np.uint8)
                
                # Decode the image
                frame = cv2.imdecode(img_array, cv2.IMREAD_COLOR)
                
                if frame is not None:
                    # Resize to 240x240 and convert to 3-channel
                    frame = cv2.resize(frame, (240, 240))
                    
                    # Try to put the frame into the queue.
                    try:
                        self.frame_queue.put(frame, block=False)
                    except queue.Full:
                        try:
                            self.frame_queue.get_nowait()
                        except queue.Empty:
                            pass
                        self.frame_queue.put(frame, block=False)
                
                # Enqueue buffer back for reuse
                self.client.enqueue_buffer(buf)
            
            except Exception as e:
                print(f"Error in _update: {e}")
                continue
    
    def read(self):
        """
        Block until a frame is available and return the latest frame.
        This mimics the blocking behavior of cap.read(), but always returns the latest frame.
        """
        frame = self.frame_queue.get()  # This call blocks until a frame is available.
        return True, frame.copy()
    
    def isOpened(self):
        return self.running
    
    def release(self):
        self.running = False
        if self.client:
            self.client.stop()
        self.frame_queue.queue.clear()

# Testing code:
test = True
if test:
    if __name__ == "__main__":
        cap = MJPEGVideoCapture("http://openiristracker.local")
        cap.open()
        
        while cap.isOpened():
            ret, frame = cap.read()
            if ret:
                cv2.imshow("MJPEG Stream", frame)
            
            if cv2.waitKey(1) & 0xFF == ord("q"):
                break
        
        cap.release()
        cv2.destroyAllWindows()
